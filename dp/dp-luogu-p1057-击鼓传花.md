# [`P1057. NOIP2008` 普及组. 传球游戏、击鼓传花](https://www.luogu.com.cn/problem/P1057)

n 个同学，围成一个圆圈，指定某人手里拿一束花。每人都可以把花传给自己左右两人之一，左右任意。

有多少种不同的方法，可以使从小蛮手里开始传的花，传了 m 次以后，又回到小蛮手里。

两种方法，按接花顺序组成的序列，如果是不同的，则视为两种不同的方法。

例，三个人，编号 1、2、3，从 1 号手里开始传。传了 3 次回到 1 号手里的方式共有 2 中，1->2->3->1 和 1->3->2->1。

# 题解

`dp[i][j]`: 「花开始在 1 号手里，经过 i 次传递，到 j 号手里」的传递方式，有多少种。

如果 i 次后到达 j，则 `i-1` 次时必然在 j 左边或 j 右边，通常就是 `j-1` 和 `j+1`，所以 `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]`。但这里是个环形，得处理一下边界情况。

初值:

从递推公式看，`dp[i][j]` 只用到了上一行的结果 `dp[i-1][.]`，没用到本行结果。所以只要有上一行的结果就可递推。只要初始化 `dp[0][.]` 这一行就可以开始递推。
- `dp[0][1] = 1`: 花开始在 1 号手里，经过 0 次传递，到 1 号手里。只有 1 种方式。
- `dp[0][i] = 0`: 若 `i!=1`。

代码：2024.02.22 luogu ac

```cpp
    #include <iostream>
    using namespace std;
    
    int dp[31][31];
    int main() {
        int n, m;
        cin >> n >> m;
    
        dp[0][1] = 1;
        for (int i = 1; i <= m; i++) {  // m次传球
            for (int j = 1; j <= n; j++) {  // n个同学
                if (j == 1) {
                    dp[i][j] = dp[i - 1][n] + dp[i - 1][j + 1];
                } else if (j == n) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][1];
                } else {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
                }
            }
        }
        int ans = dp[m][1];
        cout << ans << endl;
        return 0;
    }
```
