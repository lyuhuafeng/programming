# 无界背包问题 unbounded knapsack problem (UKP)

每种物品可放任意多个，当然不能超过背包容量上限。

# dp 法

递推公式中，k 为物品 i 放入的数量。

```c++
c[i][j] = max(c[i-1][j], c[i-1][j - k * wi] + k * vi), ∀ k ∈ [1, W/wi]
```

考虑到“不放入”相当于“放入 0 个”，也可写成

```c++
c[i][j] = max(c[i-1][j - k * wi] + k * vi), ∀ k ∈ [0, W/wi]
```

定义状态数组，下标从 0 开始：

```cpp
int dp[n + 1][W + 1]; 
```

初始化第 0 行：`dp[0][j] = 0`：没有物品放入时，最大价值显然为 0

初始化第 0 列：`dp[i][0] = 0`（在 for i 循环中）：背包最大容量为 0 时，最大价值显然为 0.

代码中，用循环打擂的方法求最大值，而不是直接 max()。

根据 dp 数组，倒推哪些物品被放入。倒推细节与 0-1 背包问题有些不同。

若 `dp[i][j] > dp[i-1][j]`，背包容量不变，但最大价值变化，说明物品 i 被放入。但放了几件，要再用个循环找一下。

用数组 `num[]` 记录每种物品放入了几件。

完全背包问题UKP，动态规划法，代码

代码：[knapsack-ukp-dp-2d.cpp](code/knapsack-ukp-dp-2d.cpp)

# dp 法，优化

对第 i 种物品

如果不放入，则 `dp[i][j] = dp[i-1][j]`

如果放入，随着 j 增加，可放入的数量逐渐增加。

放入多件，可以考虑成逐次放入，每次放入一件。在 j 较小时，已最大限度放了物品 i。现在若还能放，就只能多放一件，再多了放不下。所以不用比较 0 件到最多件，只要比较少一件的就行。

即，在 j 循环中，`dp[i][j] = dp[i][j-wi] + vi`

代码：[knapsack-ukp-dp-2d-improved.cpp](code/knapsack-ukp-dp-2d-improved.cpp)

注意跟 0-1 背包问题对比，只有一处不同。<font color="red">待深入思考。</font>

```cpp
    for (int i = 1; i <= n; i++) {
        dp[i][0] = 0;
        for (int j = 1; j <= W; j++) {
            if (j < w[i]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);
// 0-1:         dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
// 0-1:                                         ~~~~~ 这里是 i-1，而不是 i
            }
        }
    }
```

# dp 法，空间压缩为一维数组

但无法倒推哪些物品放入了多少件

# 递归法

但无法倒推哪些物品放入了多少件

代码：[knapsack-ukp-recursive.cpp](code/knapsack-ukp-recursive.cpp)

