# 动态规划：正整数 N，划分成 K 个可能相同的正整数之和，顺序无关

[l4, u15, ex2: 整数的划分](https://oj.youdao.com/course/13/83/1#/1/9427)

正整数 N，划分成 K 个「可能相同」的正整数之和，共多少种解法。

split N as sum of K numbers

初看貌似是多重背包恰好装满问题，其实不是。物品总量是给定的 K，而多重背包问题里是不限的。

# 法一

`dp[i][j]`: 和为 i，分成 j 个正整数，的方案数。

考虑在拆分为 j 份时，是否包含数 1。
* 若 j 份中不包含 1：为保证每个数大于 1，先拿出 j 个 1 分给每份，再把剩下的 i-j 「正常」分成j份。有 `dp[i-j][j]` 种方法。
* 若 j 份中包含 1：先拿出 1 作为一份，剩下 i-1「正常」分成 `j-1` 份。有 `dp[i-1][j-1]` 中方法。「正常」的意思是，里面可能含有 1。本题中，分成的各份允许相同，剩下 i-1 是「正常」分。若各份要求不同，则不能「正常」分，否则分出来可能有 1，与先拿出的 1 这份相同了。
* 所以，`dp[i][j] = dp[i-j][j] + dp[i-1][j-1]`。（前者不含 1，后者含 1）
* 初始化，见代码

以上是课上教的方法。与我们习惯的 dp 定义的 i、j 定义是反的。按习惯的方法：
* `dp[i][j]`: 和为 j，划分成 i 个正整数，的方案数。
* `dp[i][j] = dp[i][j-i] + dp[i-1][j-1]`。（前者不含 1，后者含 1）

```cpp
const int mod = 1e9 + 7;
// k 个数，可能有相同的，和为 n
int sum_of_k(int n, int k) {
  int dp[k + 1][n + 1]; // dp[i][j]: i个数，和为j，的方案数
  for (int j = 1; j <= n; j++) {
    dp[1][j] = 1;
  }
  for (int i = 2; i <= k; i++) {
    dp[i][1] = 0;
    for (int j = 2; j <= n; j++) {
      if (j <= i) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = (dp[i][j - i] + dp[i - 1][j - 1]) % mod;
      }
    }
  }
  return dp[k][n];
}
```

## 若不允许数相同：

`dp[i][j]`: 和为 j，划分成 i 个正整数，的方案数。
* 不含 1：一样。`dp[i][j-i]` 种方案。
* 含 1：先拿出来 1 作为 1 份。剩下 j-1 要分成大于 1 的 i-1 份，先取 i-1 个 1 分给每份，剩下 (j-1)-(i-1)「正常」分成 i-1 份，方案数为 `dp[i-1][(j-1)-(i-1)]`，即 `dp[i-1][j-i]`。
* 综合：`dp[i][j] = dp[i][j-i] + dp[i-1][j-i]`。（前者不含 1，后者含 1）

代码略

# 法二

`dp[i][j]` 表示，和为 j，划分结果最大为 i（也就是在 1..i 里选）
* 若 `i > j`，显然 i 太大，无法放入，结果为 `dp[i-1][j]`。(如果 i-1 仍大于 j…… 最后等于 `dp[j][j]`)
* 若 `i ≤ j`，i 可放入：
  * 若 i 放入，结果为 `dp[i-1][j-i]`
  * 若 i 不放入，结果为 `dp[i-1][j]`

递推初值：只用到了 `dp[i-1][.]`。所以只要初始化首行即可。
* `dp[1][j]=1`: 在 1..1 里选若干，和为 j。显然只有 `dp[1][1]=1`，其余为 0。






