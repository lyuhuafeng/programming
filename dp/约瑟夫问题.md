# 约瑟夫问题 
## Josephus problem, Josephus permutation

弗拉维奥·约瑟夫斯 Flavius Josephus, 一世纪的犹太历史学家

n 个人，编号从 1 到 n。围成一桌坐下，从编号为 1 者开始报数，每次第 k 个人离席。从离席者的下一位在座成员开始，重新开始报数。求最后剩下的人的编号。

递推公式：
```cpp
    // 编号从 1 开始
    f(n,k) = (f(n-1, k) + k - 1) % n + 1
    f(1,k) = 1
```
若编号改成从 0 开始：

```cpp
    // 编号从 0 开始
    f(n,k) = (f(n-1, k) + k) % n
    f(1,k) = 0
```

如何得到这个递推公式？若编号从 0 开始，第一个人被删掉后，剩下 n-1 个人，起点不再是编号 0 者，而是编号为 `k % n` 者。所以得到 `f(n-1, k) + k % n`（从坐标系变换、原点平移的角度，较好理解）。从 mod 运算的角度，等于 `(f(n-1, k) + k) % n`。<font color="red">（问题：有些人被删了，有些编号跳过去了，这一点如何理解？）</font>

https://www.zhihu.com/tardis/zm/art/121159246 这里有更严格的数学解释。

递归代码，编号从 1 开始：

```cpp
    int josephus(int n, int k) {
        return n > 1 ? (josephus(n - 1, k) + k - 1) % n + 1 : 1;
    }
```

非递归代码，编号从 1 开始。实际代码中用了「编号从 0 开始」的递推公式，最后结果加 1。<font color="green">注意，i 的循环从 1 到 n，所以 pos 初值对应 f₀。f₀ 其实是没有意义的（共 0 个人，最后剩下谁？），但作为递推初始值，则恰好能正确推出 f₁ = 0。另一种方法则是令 pos 初值对应有意义的 f₁，则 i 的循环从 2 开始。</font>

```cpp
    int josephus(int n, int k) {
        int pos = 0;
        for (int i = 1; i <= n; i++) { // i 初值也可以是 2
            pos = (pos + k) % i; // fᵢ = (fᵢ₋₁ + k) % i
        }
        return pos + 1;
    }
```

# 进一步简化

若 k >> n，则转一圈可删掉若干个。时间复杂度 `O(k*logn)`。
- [https://zhuanlan.zhihu.com/p/35487124](递推解法)
- [https://cp-algorithms.com/others/josephus_problem.html](递归解法)

# 暴力解法

`O(n)`

线段树解法：`O(nlogn)``

# 例题

[LCR 187. 破冰游戏](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

编号从 0 开始，最后不用加 1。题目说「从 0 号成员起开始计数，排在第 target 位的成员离开圆桌」，经手工解 case 1，认定，是「计数从第 1 个开始，第 target 个离开」。

```cpp
    int iceBreakingGame(int num, int target) {
        int pos = 0;
        for (int i = 1; i <= num; i++) {
            pos = (pos + target) % i;
        }
        return pos;
    }
```

# 特例: k = 2

隔一个删一个，递推公式为
```cpp
    f(1) = 1
    f(2n) = 2f(n) - 1, n ≥ 1
    f(2n+1) = 2f(n) + 1, n ≥ 1
```

将 n 写成 `n = 2ᵏ + l`，则通项公式为
```cpp
    f(n) = f(2ᵏ + l) = 2l + 1
```

更简单地，写出 n 的二进制，把最左边的 1 移到最右边，即可。

# 反约瑟夫问题

通过 n 和其他信息，求 k

