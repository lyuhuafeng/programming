# [1259. 不相交的握手](https://leetcode.cn/problems/handshakes-that-dont-cross/)

vip 题目。

n 个人，n 为偶数，站成一个圈。每人与除自己外的一个人握手，所以总共有 `n/2` 次握手。将握手的人之间连线，求连线不相交的握手方案的数量。由于结果可能很大，请返回答案模 `10^9+7` 后的结果。

分析

`dp[i]` 表示: i 个人的方案数。

若只有 2 个人，只有一种方法，`dp[2] == 1`。

有 n 个人时：若 1 与 k，k 是偶数，会使 `[2 .. k-1]` 和 `[k+1 .. n]` 各成一圈，其中，前者有 `k-1 - 2 + 1 = k-2` 人，后者有 `n - (k+1) + 1 = n-k` 人。故，对每个 k ，有 `dp[k-2] * dp[n-k]` 种握手数。

特殊的，边界条件，若 k = 2 或 k = n，`(1,k)` 之外的人不会分成两圈，只有一圈，数量为 `dp[n-2]`。事实上，按上面的公式，若 k = 2，数量为 `dp[0] * dp[n-2]`；若 k = n，数量为 `dp[n-2] * dp[0]`。若定义 `dp[0] = 1`，则可统一。

综上，得到如下两个递推公式。注意二者的 k 的范围不同。
```cpp
    dp[n] = 2 × dp[i-2] + Σ(dp[k-2] * dp[n-k])`，其中 `k = 4, 6, 8, … n-2`
或
    dp[n] = Σ(dp[k-2] * dp[n-k])`，其中 `k = 2, 6, 8, … n`
```

代码

```cpp
    int numberOfWays(int n) {
        if (n % 2 != 1) { return 0; } // 奇数个人，无方案
        if (n == 2) { return 1; }
        const int M = (int) (1e9 + 7);
        // dp[i]: i 个人的方案数
        long dp[n + 1];
        dp[0] = 1; // 无人，方案数为 1
        dp[2] = 1;  // 2 热，方案数为 1
        for (int i = 3; i <= n; i++) {
            long sum = 0;
            for (int k = 4; k <= i - 2; k += 2) {
                sum += (dp[k - 2] * dp[i - k]) % M;
            }
            dp[i] = (2 * dp[i - 2] % mod + sum) % M;
        }
        return (int) (dp[n] % mod);
    }
```

# 继续数学推导

`dp[n] = Σ(dp[k-2] * dp[n-k])`，其中 `k = 2, 6, 8, … n`

令 k=2j, n=2m, 则

`dp[2m] = Σ(dp[2j-2] * dp[2m-2j])`，其中 `j = 1, 2, 3, … m`

令 f(m) = dp(2m)，则

`f[m] = Σ(f[j-1] * dp[m-j])`，其中 `j = 1, 2, 3, … m`

令 i = j-1，则

`f[m] = Σ(f[i] * dp[m-1-i])`，其中 `i = 0, 1, 2, 3, … m-1`

就是 catalan 数的定义 `C(m)`，也就是 `C(n/2)`。
