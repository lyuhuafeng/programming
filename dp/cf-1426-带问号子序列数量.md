# codeforces 1426. Number of Subsequences

- [luogu cf1426f](https://www.luogu.com.cn/problem/CF1426F)
- [l4, l15, ex5](https://oj.youdao.com/course/13/83/1#/1/9473)

给定一个含有 `abc?` 的字符串，`?` 可展开为 `abc` 中的任意一个，求所有可能的无 `?` 字符串中，子序列 `abc` 出现的次数。

# 解析

`dp[i][j]` 表示：
- `dp[i][1]`：前 i 个字母里，子序列 a 的个数。
- `dp[i][2]`：前 i 个字母里，子序列 ab 的个数。
- `dp[i][3]`：前 i 个字母里，子序列 abc 的个数。
所求答案就是 `dp[n][3]`。

转移递推公式：

若第 i 位是 a，`dp[i][1] = dp[i-1][1] + 3k` (公式 1)
- 前者，前 i-1 个字符里，a 子序列的个数，继承下来。
- 后者，新增的 a 导致新增的 a 子序列。设前 i 位里有 k 个 `?`，每个 `?` 有 `a、b、c` 三种可能，会将原先的串变为 `3^k` 个串，每个串里在的第 i 位都是 a，所以要算 `3^k` 次。

若第 i 位是 b，`dp[i][2] = dp[i-1][2] + dp[i-1][1]` (公式 2)
- 前者，前 i-1 个字符里，ab 子序列的个数，继承下来。同上。
- 后者，新增的 b 导致新增的 ab 子序列。等于：前 i-1 个字符里，a 子序列的个数。每个这种 a 子序列，与新增的 b，构成一个 ab 子序列。

若第 i 位为 c，`dp[i][3] = dp[i-1][3] + dp[i-1][2]` (公式 3)
- 解释同上。

若第 i 位为 `?`，上面公式 (1)(2)(3) 的第一项要乘以 3，第二项不变。
- 第一项对应前 i-1 位里的“完整”子序列，与 `?` 变成的任何一个字符匹配，都是“完整”子序列，所以要乘以 3。
- 第二项是前 i-1 位里的“不完整”子序列，只能与 `?` 变成的某一个字符凑成“完整”子序列，所以不用乘以 3。

初值：`dp[0][j] = 0`

k 的初值（代码里直接用 k 代替上面分析中的 `3^k`）:
- 开始 0 个 `?`，k初值为 `3^0 = 1`。
- 每次遇到 `?`，先更新 dp，用到的是前 i-1 个字符（而不是前 i 个字符）里的 `?` 数量，再更新 `k = k*3`。

代码

```cpp
    #include <cstdio>
    using namespace std;
    
    char s[200005];
    long long dp[200005][4];
    const long long mod = 1e9 + 7;
    
    int main() {
        int n;
        scanf("%d%s", &n, &s[1]);
        long long k = 1;
        for (int i = 1; i <= n; i++) {
            if (s[i] == 'a') {
                dp[i][1] = (dp[i - 1][1] + k) % mod;
                dp[i][2] = dp[i - 1][2];
                dp[i][3] = dp[i - 1][3];
            } else if (s[i] == 'b') {
                dp[i][1] = dp[i - 1][1];
                dp[i][2] = (dp[i - 1][2] + dp[i - 1][1]) % mod;
                dp[i][3] = dp[i - 1][3];
            } else if (s[i] == 'c') {
                dp[i][1] = dp[i - 1][1];
                dp[i][2] = dp[i - 1][2];
                dp[i][3] = (dp[i - 1][3] + dp[i - 1][2]) % mod;
            } else {
                dp[i][1] = (dp[i - 1][1] * 3 + k) % mod;
                dp[i][2] = (dp[i - 1][2] * 3 + dp[i - 1][1]) % mod;
                dp[i][3] = (dp[i - 1][3] * 3 + dp[i - 1][2]) % mod;
                k = (k * 3) % mod;
            }
        }
        printf("%lld", dp[n][3]);
        
        return 0;
    }
```
