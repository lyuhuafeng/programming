# sparse table，用于解 RMQ 问题的 dp 算法

RMQ: range minimum/maximum query 区间最值。对于长度为 n 的序列 A，回答若干个询问 `(A, i, j)`；每个询问返回序列 A 中在 `[i, j]` 范围内的最大（小）值或其下标。

广义地，可用于「可重复贡献」问题。对于运算 f，满足 `f(x, x) = x`，则对应的区间询问就是一个「可重复贡献」问题。min, max 都是；gcd 也是。「区间和」不是。

更广义地，满足下列两个条件的问题，都可用 sparse table 方法：
- 可结合的 associative：`f(a, b, c) = f(a, f(b, c)) = f(f(a, b), c)`
- 不怕重叠的 overlapping friendly: `f(a, b, c) = f(f(a, b), f(b, c))`

## 法一：纯暴力

略

## 法二：普通 dp

以求「区间最小值」rmq 为例。`f(l, r)` 表示 `[l, r]` 下标范围内的最小值。递推公式为：

```cpp
    f(l, r) = min(f(l, r-1), A[r])
```

整个预处理耗时 `O(n^2)`。随后每次查询耗时 `O(1)`。总共耗时 `O(n^2 + m)`。

法三：sparse table 法

在法二基础上，设法压缩预处理的时间。

把每个 range 写成若干 2 的次方之和。如，长度为 13 的区间，可写成 `8 + 4 + 1`。

若 `f(i, j)` 表示 `[i, i + 2ʲ)` 也就是 `[i, i + 2ʲ - 1]` 长度为 `2ʲ` 的区间内的最小值，
- 若 `j == 0`, 区间长度为 1，则 `f(i, 0) = A[i]`
- 否则，可分成两个长度为 `2ʲ⁻¹` 的区间，`f(i, j) = min(f(i, j-1), f(i + 2ʲ⁻¹, j-1))`

查询时，先找到 `[l, r]` 区间内最大的「2 的幂」长度，记为 `2ᵏ`。`k = ⌊log2(r - l + 1)⌋` 向下取整。例如，区间 `[2, 12]`，长度为 13，最长的「2 的幂」为 `2^3 = 8`，即 `k = int(log2(13)) = 3`。

然后分成两个可能重叠的区间 `[l, l + 2ᵏ⁻¹ - 1]` 和 `[r - 2ᵏ⁻¹ + 1, r]`，递归求解。即 `f(l, r) = min(f(l, k), f(r - 2ᵏ⁻¹ + 1, k))`。注意，对 rmq 问题来说，区间重叠并不影响结果。

预处理耗时 `O(nlogn)`。每次查询耗时 `O(1)`。总共耗时 `O(nlogn + m)`。

ref:
- https://www.baeldung.com/cs/sparse-tables

