# [871. 最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)

dp 或 greedy，代码：[`min-refuels-leet-871-dp-greedy.cpp`](code/min-refuels-leet-871-dp-greedy.cpp) leetcode ac

# dp 法

状态定义
- `dp[i][j]`：`[0, i - 1]` 范围内的加油站，<font color="green">最多</font>加 `j` 次油，能走的最远距离。注意，<font color="green">是「最多」，而不是「恰好」</font>。

求 `dp[i][j]` 的状态转移方程
- 若在第 `i - 1` 个加油站加油，则 `dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1]`。前提：得先能到第 `i - 1` 个加油站，也就是 `dp[i][j - 1] >= stations[i - 1][0]`。
- 若不在第 `i - 1` 个加油站加油，则 `dp[i][j] = dp[i - 1][j]`。
- 取两种情况的最大值。

初始化
- 从递推关系来看，求 `dp[i][j]`，需要知道 `dp[i-1][j-1]` 和 `dp[i-1][j]`。所以，需要初始化第一行 `dp[0][.]` 和每行的第一个 `dp[i][0]`。
- `dp[0][j]`，无加油站，能走的距离为 `startFuel`。
- `dp[i][0]`，加 0 次油，能走的最远距离为 `startFuel`。

答案
- 遍历最后一行，`j` 从小到大，找到第一个使 `dp[n - 1][j] >= target` 的 `j`。

# 贪心法

为使加油次数最少，应在确保每个位置都能到达的前提下，选油量最大的加油站加油。

为得到所有经过的加油站中的最大油量，需用 pq 记录各油量。

从左到右遍历 stations 数组。对每个加油站，先判断它否可达，再将其油量加入 pq。对目的地，只需判断是否可达。

具体：计算「当前位置」（加油站或目的地）与「上一位置」的距离差。根据该距离差，得到从「上一位置」到「当前位置」所需油量，将该油量从「剩余油量」中减去。若「剩余油量」小于 0，说明，若不加油，无法从「上一位置」行驶到「当前位置」，需要从 pq 中取出最大油量，用来加油。

<font color="red">总感觉有点不对劲。</font>