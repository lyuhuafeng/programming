# [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

题目：对整数 n ，恰由 n 个节点组成、且节点值从 1 到 n 互不相同的二叉搜索树有多少种？

# 思路

给定一个有序序列 `[1 .. n]`，为了构建出一棵二叉搜索树，可遍历每个数字 i，以其为树根，将 `[1 ... i-1]` 序列作为左子树，将 `[i+1 ... n]` 序列作为右子树。再以同样方式，递归构建左子树和右子树。

构建过程中，由于根不同，故每棵二叉搜索树都是唯一的。

定义两个函数：

- `g(n)`: 长度为 n 的序列能构成的不同二叉搜索树的个数。
- `f(i,n)`: 以 i 为根、序列长度为 n 的不同二叉搜索树个数。`1 ≤ i ≤ n`。

`g(n)` 是实际所求。

`g(n)` 可以从 `f(i,n)` 得到，而 `f(i,n)` 又递归地依赖于 `g(n)`。

不同的二叉搜索树的总数 `g(n)`，是遍历所有 i 的 `f(i,n)` 之和。

```cpp
    g(n) = ∑f(i, n), 对所有 i ∈ [1,n] 求和
```

边界情况：`g(0) = 1`，`g(1) = 1`，分别对应空树、只有一个节点的树。

对序列 `[1 .. n]`，以 i 为根的二叉搜索树，是其左子树集合与右子树集合的笛卡尔积。每个可能的左子树，与每个可能的右子树，再加上 i 做根，就得到一个完整的二叉搜索树。由于 `g(n)` 的值只与序列长度有关，与序列内容无关，所以，

```cpp
    f(i, n) = g(i-1) * g(n-i)，其中 1 ≤ i ≤ n
```

上两个公式结合，得到：
```cpp
    g(n) = ∑(g(i-1) * g(n-i))，对所有 i ∈ [1,n] 求和
```

正序枚举 i 即可。

```cpp
    int numTrees(int n) {
        vector<int> g(n + 1, 0);
        g[0] = 1;
        g[1] = 1;

        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                g[i] += g[j - 1] * g[i - j];
            }
        }
        return g[n];
    }
```

另外，`g(n)` 其实就是「卡特兰数」Catalan number。`g(0) = 1`, `g(n+1) = 2 * (2n+1) / n+2 * g(n)`。代码略。
