# 无界背包恰好装满: [leetcode 322: 零钱兑换](https://leetcode.cn/problems/coin-change/)

给一个价值 amount 和一些面值，每个面值的硬币数都是无限的，问最少用几个硬币能组成给定的 amount。

分析

将面值看作物品，面值金额看作物品重量，每件物品的价值均为 1，这样就是一个恰好装满的完全背包问题。

* 若不能放入（当 `j < coins[i]`）
  * `dp[i][j] = dp[i-1][j]`
* 若能放入（当 `j >= coins[i]`）
  * 若不放入，`dp[i][j] = dp[i-1][j]`
  * 若放入, `dp[i][j] = dp[i][j-c] + 1 或 -1` (若前 i 硬币放 j-c 恰好装满，则其数量 +1，否则 i 硬币、j-c 放不满，则 j 也放不满)
  * 这两种情况要结合一下：若都能装满，取硬币数较少的；若都不能装满，那最终就是不能装满，取 -1；若有一种情况能装满，就取它。

coins 是个数组，下标天然从 0 开始。<font color="red">注意</font>，`dp[i][.]` 的 i 表示“前 i 个硬币”，也就是下标范围 [0 ... i-1]，于是 `dp[0][.]` 初始化时用“0 个硬币”初始化。这点跟[`分割等和子集-leet416`](背包-1-01背包恰好装满-分割等和子集-leet416.md) 不同。后者 `dp[i][.]` 的 i 表示下标范围 `[0 ... i]`。为此，`dp[0][.]` 用“一个数 nums[0] 而不是 0 个数”做初始化。

```cpp
// 正常写法
int coinChange_2d(vector<int>& coins, int amount) {
    int n = coins.size();
    int dp[n + 1][amount + 1];
    dp[0][0] = 0;
    for (int j = 1; j <= amount; j++) {
        dp[0][j] = amount == 0 ? 0 : -1;
    }

    for (int i = 1; i <= n; i++) { // 遍历硬币
        dp[i][0] = 0;
        int c = coins[i - 1]; // 注意是 i-1。dp[i]:前i个，范围[0 ... i-1]
        for (int j = 1; j <= amount; j++) {
            if (j < c) {
                dp[i][j] = dp[i - 1][j]; // 放入不了
            } else {
                int t1 = dp[i - 1][j]; // 能放入，但不放入
                int t2 = (dp[i][j - c] == -1) ? -1 : (dp[i][j - c] + 1); // 能放入，且放入
                if (t1 == -1 && t2 == -1) {
                    dp[i][j] = -1;
                } else if (t1 != -1 && t2 != -1) {
                    dp[i][j] = min(t1, t2);
                } else {
                    dp[i][j] = max(t1, t2);
                }
            }
        }
    }
    return dp[n][amount];
}

// 空间优化，使用一维数组
int coinChange(vector<int>& coins, int amount) {
    int n = coins.size();
    int dp[amount + 1];
    dp[0] = 0;
    for (int j = 1; j <= amount; j++) {
        dp[j] = amount == 0 ? 0 : -1;
    }

    for (int i = 1; i <= n; i++) { // 遍历硬币
        int c = coins[i - 1]; // 注意是 i-1。dp[i]:前i个，范围[0 ... i-1]
        for (int j = c; j <= amount; j++) {
            int t1 = dp[j]; // 能放入，但不放入
            int t2 = (dp[j - c] == -1) ? -1 : (dp[j - c] + 1); // 能放入，且放入
            if (t1 == -1 && t2 == -1) {
                dp[j] = -1;
            } else if (t1 != -1 && t2 != -1) {
                dp[j] = min(t1, t2);
            } else {
                dp[j] = max(t1, t2);
            }
        }
    }
    return dp[amount];
}
```
