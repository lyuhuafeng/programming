## [leetcode 153: 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

长度为n的数组，按照升序排列，经1到n次旋转后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`

若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`。

给你一个旋转后的数组 `nums`，元素值互不相同，求该数组的最小元素 。

输入：`nums = [3,4,5,1,2]`  输出：`1`

输入：`nums = [11,13,15,17]`  输出：`11`

## 解法

经观察，发现，要找的是“第一个比 `nums[0]` 小”的元素。以“元素值比 `nums[0]` 小”为判断条件，可以得到 `FFFFTTTT` 序列，可使用左闭右开定式。

特例：没旋转（旋转了 `0` 次），则 `nums[0]` 就是最小的。此时找不到满足“元素值比 `nums[0]` 小”这一条件的元素，`while` 循环结束后，`l` 值为 `r`的初始值（最后元素之后），需判断一下。

```java
    int find_min(int[] nums) {
        int l = 0, r = nums.length; // r:最后元素之后，右开区间
        while (l < r) {
            int m = l + (r - l) / 2;
            if (nums[m] < nums[0]) { // predicate(m) == true
                r = m;
            } else {
                l = m + 1;
            }
        }
        return l == nums.length ? nums[0] : nums[l]; // 是否找到
    }
```