
concurrency（并发）vs. parallelism（并行）

![pic](pics/concurrency-vs-parallelism-by-joearms.jpeg)

concurrent 并发
- 多个 queue，一个 resource 或 server
- 单个 server 通过 context switching 来服务多个任务，造成「并行」的假象
- 通常就是「单核 cpu」

parallel 并行
- 多个 queue，多个 resource 或 server
- 真正意义上的并行
- 通常就是「多核 cpu」

asynchronous 异步
- 允许程序在等待一个操作完成的同时继续执行其他代码，从而避免阻塞
- 本质上与并发（多任务同时进行）无关，而是关注于单个任务在等待时的处理方式


异步编程模式，多数都是采用 Future、Promise 模型。
- Future 是一个「placeholder object 或 context」，先创建好，用来存放一个将来会出现、但现在还不存在的结果。是「只读」的。
- Promise 是某 future 的最终结果，是与该 future 相关联的「单次赋值变量 single-assignment container」，用于存放最终计算得到的值。

这两个概念，其实区别不大。

类似术语: delay, deferred

主要编程语言都引入了异步编程
- Java：Java 8 引入了 CompletableFuture。
- Python：python 3.4 引入 asyncio 库，用 async 和 await 关键字来编写异步代码。这标志着对 futures 和 promises 概念的原生支持。
- JavaScript：ECMAScript 2015 (ES6) 引入了 Promise。
- C#：引入 Task 类和 async/await 语法

async/await vs. callback
- callback 通常是在某个操作完成时被调用的函数，它们使得代码的执行流程变得不连续和分散。若逻辑较简单，还好处理一些。若逻辑变复杂（如多个异步操作的依赖和协调），逻辑可能分散在多个 callback 中，不易理解和维护。(称为 callback hell)
- 在 async/await 出现后，就不必再用 callback 了。

「续作」continuation
- 异步编程的本质是围绕 continuation 这个概念展开。
- 当函数遇到异步操作时，它不会阻塞等待操作完成，而是立刻将控制权返回给调用者，并将其余的函数体封装成一个待后续操作的 continuation。这意味着，一旦异步操作完成，这个 continuation 便会被触发，继而执行函数的剩余部分。
- await 自动帮我们处理了 continuation。

continuation vs. callback
- callback 比 continuation 的概念更广泛
- continuation 特指能保存函数执行状态的 callback，这在某种程度上类似于 coroutine 的工作方式。


# Java 8: CompletableFuture

但没有一个明确的 promise 类。

例：异步计算阶乘

```java
    int num = 12;
    CompletableFuture<Long> cf = CompletableFuture.supplyAsync(() -> factorial(num));
    while (!cf.isDone()) {
        System.out.println("CompletableFuture is not finished yet...");
    }
    long result = cf.get();
```

# python 3.7: asyncio

一个 module：`asyncio`；两个 keyword：`async`, `await`

设计思路：single-threaded, single-process

「多任务合作」模式 (cooperative multitasking)，允许异步任务交出执行权给其他任务，等到其他任务完成，再收回执行权继续往下执行。

这种模式，尽管是单进程单线程，但仍然造出了 concurrency 的感觉。coroutines 可以 concurrently 调度，但并不是真的 concurrent 的。

代码的执行权在多个 coroutine 之间切换，看上去好像多个任务同时运行，但其实底层只有一个线程，多个任务分享运行时间。

为什么只用单线程，不利用系统的多 cpu core？因为单线程简化了很多问题，使代码逻辑简单、写法符合直觉。

async IO 是一种 concurrent programming, 但不是 parallelism.


```python
    import asyncio

    # 函数前面加上 async 关键字，就成了 async 函数。这种函数最大特点是：执行可以暂停，交出执行权。
    async def count():
        print("one")
        await asyncio.sleep(1)
        print("two")

    # 函数前面加上 async 关键字
    async def run():
        await asyncio.gather(count(), count(), count())

    if __name__ == "__main__":
        asyncio.run(run()) # 运行
```


