# [`316.` 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)
# [`1081.` 不同字符的最小子序列](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters) 

两道题目相同

如果只满足字典序最小，则越小的字符越往前放，是个单调（不严格）递增栈。

但如果某字符只有一个，则扫描到它就得将其入栈。

所以，新来的 c 入栈，需要被弹出的栈顶字符 t，得满足两个条件
- (1) t < c; 且 
- (2) t 以后还有（现在弹出，以后还能放入）


```cpp
    string removeDuplicateLetters(string s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        // 第 1 步：记录每个字符出现的最后一个位置
        int last_index[26];
        for (int i = 0; i < len; i++) {
            last_index[s[i] - 'a'] = i;
        }

        string st;
        vector visited(26, false);

        for (int i = 0; i < len; i++) {
            char c = s[i];
            if (visited[c - 'a']) {
                continue;
            }

            // 如果只满足字典序最小，则越小的字符越往前放，是个单调（不严格）递增栈。
            // 但如果某字符只有一个，则扫描到它就得将其入栈。所以，
            // 新来的 c 入栈，需要被弹出的栈顶字符 t，得满足两个条件
            // (1) t < c; 且 (2) t 以后还有（现在弹出，以后还能放入）
            while (!st.empty() && c < st.back() && last_index[st.back() - 'a'] > i) {
                char t = st.back();
                st.pop_back();
                // 在出栈、入栈的时候，都需要维护 visited 数组的定义
                visited[t - 'a'] = false;
            }
            st.push_back(c);
            visited[c - 'a'] = true;
        }
        return st;
    }
```
