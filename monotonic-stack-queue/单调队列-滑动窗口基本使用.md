# 单调队列 monotonic queue

两种：
* 单调上升队列：increasing monotonic queue
* 单调下降队列：decreasing monotonic queue

底层实现，可用 `linked list`、`stack` 或 `deque`。通常用 `deque`。

新元素来时，队里所有比新元素大（小）的，都弹出，新元素再入队。

但这子序列也不能仅满足“单调”就可以了！

为了形成单调上升子序列，有两种方法：
* 新元素若比队尾元素小，则新元素不入队，跳过；
* 新元素若比队尾元素小，则把队尾比新元素大的所有元素都弹出，新元素入队。

单调上升队列（以及单调上升栈）采取的是第二种方法。

可以记忆为：<font color=red>新元素有高优先级！每个新元素来了都强势入队，为此不惜去掉一些队尾元素！但过一会可能作为旧元素被干掉！</font>

若以队头为 `q0`，队内元素依次为 `q1, q2, …`，则在任一时刻，单调上升：`q0 < q1 < q2 < … < qn`。

队里某元素 `q<sub>i</sub>`，是 `(q<sub>i-1</sub>, q<sub>i</sub>]` 左开右闭范围内的最小值。

注意该范围不包含 `q<sub>i-1</sub>`；显然 `q<sub>i-1</sub>` 比 `q<sub>i</sub>` 还小。

特别地，`q0` 是 `[a0, q0]` 范围内的最小值。

感觉跟 `heap` 有点像。流式处理，新元素到来，加入，动态调整，调整完后还满足一定条件。

## 基本代码：如何形成单调队列

```cpp
#include <iostream>
#include <deque>
using namespace std;

// 单调上升队列。队内存储元素值。
deque<int> increasing_monotonic_queue(int a[], int n) {
    deque<int> q;
    for (int i = 0; i < n; i++) {
        while (!q.empty() && q.back() > a[i]) { 
            q.pop_back();
        } // 比我大的，都弹出，给我腾地方
        q.push_back(a[i]);
    }
    return q;
}

int main() {
    int arr[] = { 3, 1, 2, 3, 1, 4, 5, 6 };
    int n = sizeof arr / sizeof(arr[0]);
    deque<int> q = increasing_monotonic_queue(arr, n);
    for (int i : q) { cout << i << " "; }
    return 0;
}
```

与单调栈类似，遍历完整个序列、得到了一个单调队列，好像也什么用。真正的用处，是在遍历过程中、维护这个单调队列的过程中，干点事情。

单调队列的主要作用，是在这个过程中，求一个滑动窗口范围内的最大值、最小值。

## 单调队列 + 滑动窗口

单调队列的基本用法：求滑动窗口内的最大值、最小值。可当做单调队列模板代码。

[leetcode 239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

[滑动窗口/单调队列（L5，单元8，队列进阶，题2）](https://oj.youdao.com/course/37/276/1#/1/14199)

有一个长为 `n` 的序列 `a`，以及一个大小为 `k` 的窗口。这个窗口从左向右滑动，每次滑动一个单位，求每次滑动后窗口中的最大值和最小值。

## 解法

普通单调队列稍微变化了一下，只在滑动 `k` 范围内。流式动态调整，队头元素仍然是 `k` 窗口范围内到该元素为止的最小值。


求窗口内 max 值，用单调递减队列。队头为所求 max 值。

queue 中存放元素的下标，而不是值。因为要用下标来判断窗口范围。

新元素入队之前，有两件事：清理队头的旧元素（已经超出k窗口范围的元素）；清理队尾比新来的还小的元素。这两件事先做哪个都行，顺序不影响结果。

清理队头时，判断队头元素是否已超出 `k` 窗口范围：`front + k <= i`，用 `<=` 而不是 `<`。如何记忆？窗口里包含 `k` 个元素，倒着数，即：`i, i - 1, i - 2, ..., i - (k - 1)`。再小的，都在窗口外。也即，满足 `front < i - (k - 1)` 的 `front` 都被清掉。由 `front < i - (k - 1)` 可得 `front + k <= i`。

清理队尾时，`a[q.back()] < a[i]` 这里用 `<` 还是 `<=`？从“队头是最值”的角度出发，是否相等都可以。即使queue里有相同的（不严格递增、递减），也不影响从队头取最值。<font color=red>真的吗？经我画图分析，是真的。</font>

求 max 值、min 值的代码，只有一个符号的差别，就是在清理队尾时。max值（↘ 队列）是 `a[q.back()] < a[i]`，min 值（↗ 队列）是 `a[q.back()] > a[i]`。

```cpp
// 找窗口内 max 值
// 用单调 ↘ 队列，队头为所求 max 值的下标
vector<int> maxSlidingWindow(vector<int>& a, int k) {
    vector<int> r;
    deque<int> q;
    for (int i = 0; i < a.size(); i++) {
        while (!q.empty() && q.front() + k <= i) { // 用 '<='，不能用 '<'
            q.pop_front();
        } // 以上清理队头
        while (!q.empty() && a[q.back()] < a[i]) { // 用 '<=' 也可以
            q.pop_back();
        } // 以上清理队尾
        q.push_back(i); // 新元素入队尾
        if (i + 1 >= k) {
            r.emplace_back(a[q.front()]);
        }
    }
    return r;
}
```

```cpp
// 找窗口内 min 值
// 用单调 ↗ 队列，队头为所求 min 值的下标
void min_deque(long long a[], int n, int k) {
    deque<int> q;
    for (int i = 0; i < n; i++) {
        while (q.size() > 0 && q.front() + k <= i) {
            q.pop_front();
        }
        while (q.size() > 0 && a[q.back()] > a[i]) { // 大于号，与max值的唯一差别
            q.pop_back();
        }
        q.push_back(i);
        if (i + 1 >= k) {
            printf("%lld ", a[q.front()]);
        }
    }
    printf("\n");
}
```




<font color=red>
### to do later
</font>


若 `qk<sub>0</sub>` 是 `a<sub>0</sub>` 到 `qk<sub>0</sub>` 范围内的最小值，自然也是“`k` 范围内的最小值”。

否则，若 `qk0` 是 `(qk<sub>0-1</sub>, qk<sub>0</sub>]` 范围内的最小值，其中 `qk<sub>0</sub> - 1` 在 `k` 范围之外。则 `qk0` 也是“[`k` 范围开始, `qk0`]范围内的最小值”.


时间复杂度：每个位置i入队一次，出队一次（在队尾被pop，或队首被pop；尽管用了while），所以总时间复杂度 `O(n)`，单个数平均的时间复杂度 `O(1)`。

https://zhuanlan.zhihu.com/p/447209490

若序列里有重复值：当即将入队的元素和队尾此时的元素重复的时候，新来的元素其下标更晚过期，所以其优先级更高，所以队中的旧元素应当被pop掉。因此队中的元素其实是严格递减的。To think more.

变种：左右边界可以自由选择右移或不动。

https://zhuanlan.zhihu.com/p/447209490 这里有一些这样的变种题。




