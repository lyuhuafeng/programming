# [`1673.` 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/)

给定整数数组 `nums[]`、正整数 k，返回长度为 k、最具竞争力的 nums 子序列。

数组的子序列，定义为：是从数组中删除一些元素（也可能不删除）得到的序列。重点：不一定连续。

子序列的竞争力，定义为：在子序列 a 和 b 第一个不相同的位置上，如果 a 中数字小于 b 中对应数字，则称子序列 a 比子序列 b（相同长度下）更具竞争力。如，`[1,3,4]` 比 `[1,3,5]` 更具竞争力，因为，在第一个不相同的位置上，4 小于 5。（感觉，就是字典序）

# 法一，单调栈

所求结果就是单调（不严格）递增栈的前 k 个元素。不用求 next greater 神马的。

2024.02.25：为什么就是「单调（不严格）递增栈的前 k 个元素」？考虑第一个元素，若先放进去一个较大的，若后面有比它小的将其弹出并取代它，则「竞争力」变大了。这不就是「单调栈」的生成过程么。<font color="red">直观理解还是有点难。为啥一定要递增？中间有更小的不香么。</font>

<font color="red">2024.01.26：任何时刻，栈内元素都是「（不严格）递增」的，那选取哪个时刻呢？越往后，栈内已存在的「大」元素可能被后来的「小」元素弹出，导致栈内元素越来越小、栈的「坡度」越来越缓。所以应该选尽可能靠后的时刻。何时最靠后？或者是所有元素都「处理」过了，或者是「尽量处理尽可能多元素、但不得不留下一些剩余元素不处理、以使长度 >= k」。</font>

若整个栈里元素不足 k 个，则用 nums 里元素补足。

直接用 vector 当栈，省得最后还要遍历 stack 再逆序以得到结果。

重点：`st.size() + (n - i) > k`，这个条件怎么来的？新的 i 来到，还没 push 进栈，此时应该满足，所求序列的最大可能长度 `>= k`。为何有相等？因为 pop 一次再 push 一次，不影响结果。`st.size() + (n-1 - i) >= k`。栈中，是「已处理」的个数，`n-1 - i` 是「尚未处理」的个数；第 i 个，既不算在栈里「已处理」（因还未入栈），也不算在「尚未处理」中。这里用 `>= k`；若相等，则 pop() 一下，退出 while 循环，再 push() 一下，还是 `== k`，还是满足 `>= k`。

若这式子左边加 1，右边不变，则符号就从 `>=` 变成 `>` 了。

另一种理解：需要满足「nums 中剩下的元素个数」>= 「还需要的元素个数」，即 `n-1 - i >= k - st.size()`。

<font color="red">to do: 整理上面的文字；插图。看我手绘图。</font>

(2023.12.05)

```cpp
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && st.back() > nums[i] && st.size() + (n - i) > k) {
                st.pop_back();
            }
            st.push_back(nums[i]);
        }
        st.resize(k);
        return st;
    }
```

# 法二，用单调队列

（2023.09.21，自主研发，但确实比法一麻烦很多）

总长为 n，子序列长度为 k。选子序列各元素时，显然高位（靠左的）要尽量小。

子序列：`r`

选 `r1` 时，考虑到，选完 `r1` 后，要在 `nums[]` 中给剩下的 `k-1` 个子序列成员留下足够选择空间，至少留下 `k-1` 个。所以，`r1` 要在前 `n-(k-1)` 个元素中选。范围：`[1, n-(k-1)]`。

同理，`r2` 的选择范围右界是 `n-(k-1)+1`，左界是 `r1+1`。范围 `[r1+1, n-(k-1)+1]`。

依此类推，

```cpp
    r1: [1, n-(k-1)]
    r2: [r1 + 1, n-(k-1)+1]
    r3: [r2 + 1, n-(k-1)+2]
    ...
    rk: [r[k-1] + 1, n-(k-1)+(k-1)]
```

下标改成从 0 开始：

```cpp
    r0: [0, n-(k-1)-1] = [0, n-k]
    r1: [r0+1, n-k+1]
    r2: [r1+1, n-k+2]
    ...
    r[k-1]: [r[k-2]+1, n-k+(k-1)] = [r[k-2]+1, n-1]
```

`ri` 要在这样的区间里选最小的，用单调上升队列。不过窗口的长度不是固定的，左边界依赖于上一个成员的选择。

注意，先把所有已经不在窗口范围内的队头元素弹出，再处理新进入窗口的元素。

具体代码里，外循环 (i) 是子序列的 k 个成员，内循环 (j) 是新来的元素。注意，只有 `i == 0` 时，j 才循环若干次；i 的其余值，j 都只循环一次。

# 代码

```cpp
    #include <queue>
    #include <vector>
    using namespace std;
    
    // 找min值，用单调递增队列。
    // 窗口里若有多个重复最小的，则选最左边的。所以，队列里可以有重复值。
    vector<int> most_competitive(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> r(k), rv(k); // 前者：下标，后者：值
        deque<int> q;
        int wr = 0; // 其实不用初始化
        for (int i = 0; i < k; i++) {
            int wl = (i == 0 ? 0 : r[i - 1] + 1);
            // 先弹出滑出窗口范围的队头元素
            while (!q.empty() && q.front() < wl) {
                q.pop_front();
            }
            // 再处理新元素入栈。其实只有i=0时循环n-k次，以后都只循环一次。
            int wl2 = (i == 0 ? 0 : wr + 1);
            wr = n - k + i;
            for (int j = wl2; j <= wr; j++) {
                // 队里可以有重复值，while condition里用 > 而不是 >=
                while (!q.empty() && nums[q.back()] > nums[j]) {
                    q.pop_back();
                }
                q.push_back(j);
            }
            r[i] = q.front();
            rv[i] = nums[r[i]];
        }
        return rv;
    }
    
    int main() {
        vector<int> nums = { 2, 4, 3, 3, 5, 4, 9, 6 };
        int k = 4;
        vector<int> r = most_competitive(nums, k);
        display(r);
        return 0;
    }
    
    // 输出：
    // 2 3 3 4
```
