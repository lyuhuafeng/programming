# [2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/)

法一：单调栈法

类似，但对每个区间，既要求最大值，也要求最小值。

上题，得到以 i 为 min 的范围，即可得到对应的 `a[i] * times`。本题以 i 为 min、max 的两个范围肯定不同，无法用此法。但，从总体来看，i 最为最大值有 a 次，则在最终计算中以 max 形式出现 a 次；作为最小值有 b 次，则在最终计算中以 min 形式出现 b 次。这样就可以算了。

用「top 法」，遍历两遍，分别求 min 和 max。代码如下。

时间复杂度 `O(n)`。

```cpp
    long long subArrayRanges(vector<int>& nums) {
        long long ans = 0;
        // 「i 作为 max」的区间。找 i 两边的 greater 再回缩一步。下降栈。while <。哨兵：max。
        nums.push_back(INT_MAX);
        int n = nums.size();
        vector<int> st; // 用 vector 做栈，为了复用，可 clear。若用 stack，则无 clear。
        for (int i = 0; i < n; i++) {
            while (!st.empty() && nums[st.back()] < nums[i]) {
                int t = st.back();
                st.pop_back();
                int l = st.empty() ? -1: st.back();
                ans += 1ll * (i - t) * (t - l) * nums[t]; 
            }
            st.push_back(i);
        }
        // 「i 作为 min」的区间。找 i 两边的 smaller 再回缩一步。上升栈。while >。哨兵：min。
        nums[n - 1] = INT_MIN;
        st.clear();
        for (int i = 0; i < n; i++) {
            while (!st.empty() && nums[st.back()] > nums[i]) {
                int t = st.back();
                st.pop_back();
                int l = st.empty() ? -1: st.back();
                ans -= 1ll * (i - t) * (t - l) * nums[t]; 
            }
            st.push_back(i);
        }
        return ans;
    }
```


# 法二：dp 法

其实是个不复杂的递推。遍历每个区间，打擂台找该区间内的最大值、最小值。时间复杂度 `O(n^2)`。

```cpp
    long long subArrayRanges(vector<int>& nums) {
        int n = nums.size();
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            int minv = nums[i], maxv = nums[i];
            for (int j = i + 1; j < n; j++) {
                minv = min(minv, nums[j]);
                maxv = max(maxv, nums[j]);
                ans += maxv - minv;
            }
        }
        return ans;
    }
```