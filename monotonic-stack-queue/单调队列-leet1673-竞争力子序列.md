# [1673: 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/)

给定整数数组 `nums[]`、正整数 k，返回长度为 k、最具竞争力的 nums 子序列。

数组的子序列，定义为：是从数组中删除一些元素（也可能不删除）得到的序列。重点：不一定连续。

子序列的竞争力，定义为：在子序列 a 和 b 第一个不相同的位置上，如果 a 中数字小于 b 中对应数字，则称子序列 a 比子序列 b（相同长度下）更具竞争力。如，`[1,3,4]` 比 `[1,3,5]` 更具竞争力，因为，在第一个不相同的位置上，4 小于 5。（感觉，就是字典序）

# 法一，单调栈

所求结果就是单调（不严格）递增栈的前 k 个元素。不用求 next greater 神马的。

若整个栈里元素不足 k 个，则用 nums 里元素补足。

用 vector 当栈，省得还要逆序排列 stack。

`st.size() + (n - i)`。其中 `n-i` 是尚未「处理」的元素个数。

只要 `size + 该数目 <= k`，就可以先 pop 一个再 push 一个。（所以 while 的条件要用 `>` 号）

(2023.12.05)

```cpp
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && st.back() > nums[i] && st.size() + (n - i) > k) {
                st.pop_back();
            }
            st.push_back(nums[i]);
        }
        st.resize(k);
        return st;
    }
```

# 法二，用单调队列

(2023.09.21，自主研发，但确实比法一麻烦很多）

总长为 n，子序列长度为 k。选子序列各元素时，显然高位（靠左的）要尽量小。

子序列：`r`
选 `r1` 时，考虑到，选完 `r1` 后，要在 `nums[]` 中给剩下的 `k-1` 个子序列成员留下足够选择空间，至少留下 `k-1` 个。所以，`r1` 要在前 `n-(k-1)` 个元素中选。范围：`[1, n-(k-1)]`。
同理，`r2` 的选择范围右界是 `n-(k-1)+1`，左界是 `r1+1`。范围 `[r1+1, n-(k-1)+1]`。

依此类推，

```cpp
    r3: [r2+1, n-(k-1)+2]
    ...
    rk: [rk-1+1, n-(k-1)+(k-1)]
```

下标改成从 0 开始：

```cpp
    r0: [0, n-(k-1)-1] = [0, n-k]
    r1: [r0+1, n-k+1]
    r2: [r1+1, n-k+2]
    ...
    rk-1: [rk-2+1, n-k+(k-1)] = [rk-2+1, n-1]
```

`ri` 要在这样的区间里选最小的，用单调上升队列。不过窗口的长度不是固定的，左边界依赖于上一个成员的选择。

注意，先把所有已经不在窗口范围内的队头元素弹出，再处理新进入窗口的元素。

具体代码里，外循环 (i) 是子序列的 k 个成员，内循环 (j) 是新来的元素。注意，只有 `i == 0` 时，j 才循环若干次；i 的其余值，j 都只循环一次。

# 代码

```cpp
    #include <queue>
    #include <vector>
    using namespace std;
    
    // 找min值，用单调递增队列。
    // 窗口里若有多个重复最小的，则选最左边的。所以，队列里可以有重复值。
    vector<int> most_competitive(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> r(k), rv(k); // 前者：下标，后者：值
        deque<int> q;
        int wr = 0; // 其实不用初始化
        for (int i = 0; i < k; i++) {
            int wl = (i == 0 ? 0 : r[i - 1] + 1);
            // 先弹出滑出窗口范围的队头元素
            while (!q.empty() && q.front() < wl) {
                q.pop_front();
            }
            // 再处理新元素入栈。其实只有i=0时循环n-k次，以后都只循环一次。
            int wl2 = (i == 0 ? 0 : wr + 1);
            wr = n - k + i;
            for (int j = wl2; j <= wr; j++) {
                // 队里可以有重复值，while condition里用 > 而不是 >=
                while (!q.empty() && nums[q.back()] > nums[j]) {
                    q.pop_back();
                }
                q.push_back(j);
            }
            r[i] = q.front();
            rv[i] = nums[r[i]];
        }
        return rv;
    }
    
    int main() {
        vector<int> nums = { 2, 4, 3, 3, 5, 4, 9, 6 };
        int k = 4;
        vector<int> r = most_competitive(nums, k);
        display(r);
        return 0;
    }
    
    // 输出：
    // 2 3 3 4
```
