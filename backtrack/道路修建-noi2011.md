# 道路修建

https://www.acwing.com/problem/content/986/

https://www.luogu.com.cn/problem/P2052

https://oj.youdao.com/course/37/282/1#/1/14228

n 个国家，总共修 n-1 条双向道路。每条道路的修建费用：道路长度 * abs(道路两端的国家个数之差)。求总费用。

输入：第一行，n，国家数量。随后 n-1 行，是每条道路的 (起点国家, 终点国家, 长度)。

## 分析

道路的数量是 n-1，这个条件似乎无用。

从 n-1 条道路信息，可构建一个带权重的无向图。

对任一条道路 (u, v, w)，把图分成两部分，分别含 u、v。若含 u 的这部分共 k 个节点，则这条路的费用为 `w * |k - (n - k)| = w * |n - 2 * k|`。

任取一顶点做 root，把图当成树（多叉树，不是二叉树）来处理。用 dfs 遍历，分别求每个节点做 root 的子树的总结点数，就是 k。每求出一个 k，就累加其对应的修路费用。

## 重点

* dfs，但不需回溯。
* 一条路有两个端点；为了防止一条路算两遍，不是遍历每个 node，而是遍历每条路 (edge)。每条 edge 的两个 node，计算更靠上的节点（更接近整棵树的 root 的节点）对应的 k。
* 用链式前向星记录，以某节点 u 为起点的所有 edge。每条道路，实际上对应图里的两条 edge。为了不重复，dfs 时以 (node, node的parent) 为参数，防止 node 往其 parent 的方向搜索。
* 对 u-v 这条路，计算的是 u 的 k；唯一例外是 root-v 这样的路，计算的是 v 对应的 k。最终效果一样。
* 发散：开始建图时，不知道哪个顶点更靠近后来的 root，所以记录两条 edge（一条无向的 edge）。若开始就知道哪个顶点更靠近 root（但不可能），记录一条有向的 edge 就行了。

## 代码

[noi2011-roads.cpp](code/noi2011-roads.cpp)

